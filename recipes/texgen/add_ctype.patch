diff --git a/units/units.c b/units/units.c
index a5f02c6..f814965 100644
--- a/units/units.c
+++ b/units/units.c
@@ -20,11 +20,11 @@
  *
  *       Functions exported from this module
  *
- *  void units_new ( char *name, char *baseUnits )
- *  double units_convert ( char *value, char *targetUnits )
- *  char *units_reduce ( char *unitString )
- *  void units_clear_exception()
- *  char *units_check_exception()
+ *  void units_new ( char *name, char *baseUnits )
+ *  double units_convert ( char *value, char *targetUnits )
+ *  char *units_reduce ( char *unitString )
+ *  void units_clear_exception()
+ *  char *units_check_exception()
  *
  *  These are prototype in units.h, so we do not need to
  *  repeat the prototypes here.
@@ -35,6 +35,7 @@
 #include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
+#include<ctype.h>


 /*  Define a few useful constants  */
@@ -46,7 +47,7 @@ static char *divider="/";
 static char *validchars="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789. \t*^/+-";


-/*
+/*
  *-----------------------------------------------------------------
  *
  *  Structure Definitions
@@ -90,9 +91,9 @@ static Prefix *proot = NULL;

 /*
  *-----------------------------------------------------------------
- *
+ *
  *   Local Functions (not exported)
- *
+ *
  *-----------------------------------------------------------------
  */

@@ -139,20 +140,20 @@ static char *stringcopy(string)
   copy = (char *)malloc(strlen(string)+1);
   strcpy(copy,string);
   return(copy);
-}
+}

 /*  Set a string, allocating new memory  */
-static char *stringset(target, source)
+static char *stringset(target, source)
      char *target;          /*  char *pointer to be reallocated  */
      CONST char *source;    /*  source string  */
 {
   target = (char *) realloc( target, strlen(source)+1 ) ;
   strcpy(target,source);
   return(target);
-}
+}

 /*  Append a string, allocating more memory  */
-static char *stringappend(target, source)
+static char *stringappend(target, source)
      char *target;          /*  char *pointer to be reallocated  */
      CONST char *source;    /*  source string  */
 {
@@ -161,7 +162,7 @@ static char *stringappend(target, source)
   target = (char *) realloc( target, newsize ) ;
   strcat(target,source);
   return(target);
-}
+}



@@ -187,7 +188,7 @@ static Unit *createunit() {
   return u;
 }

-/*
+/*
  *  Free name and structure, but recusively
  *  destroy any units referenced in
  *  numerator or denominator
@@ -231,10 +232,10 @@ static Prefix *createprefix(name, factor)



-/*
+/*
  *-----------------------------------------------------------------
  *
- *   Error handling / Exception Handling
+ *   Error handling / Exception Handling
  *
  *  The exported unit functions all set a failure code
  *  if there is a problem.  The caller must call
@@ -341,7 +342,7 @@ void units_new ( name, baseUnits )
     uroot = newunit;
   } else {
     /* find end of list */
-    for (u=uroot; u->next!=NULL; u=u->next) {
+    for (u=uroot; u->next!=NULL; u=u->next) {
       /* do nothing */
     }
     u->next = newunit;
@@ -444,7 +445,7 @@ char *units_reduce ( unitString )
     /* exception code has already been set, so just return */
     return NULL;
   }
-
+
   /*  Assemble reduced unit string from Unit structure  */
   returnValue = stringset(returnValue,"                         ");
   sprintf(returnValue, "%lg", u->factor);
@@ -473,7 +474,7 @@ char *units_reduce ( unitString )

 /*  local functions  */

-static Unit *reduceUnit ( unitString )
+static Unit *reduceUnit ( unitString )
      char *unitString;  /*  unit string to reduce  */
 {
   Unit *u;                 /*  new reduced unit  */
@@ -520,7 +521,7 @@ static Unit *reduceUnit ( unitString )
       return NULL;
     }
   }
-
+
   /*  it may contain only letters, digits, the power character ('^'),
       decimal points, digits, +- signs, and separators
   */
@@ -548,7 +549,7 @@ static Unit *reduceUnit ( unitString )
     unitString = cp;
   }

-
+
   /*  Make a copy of unitString, and replace any "/" with " / "  */
   tokenString = stringcopy(unitString);
   numeratorlen = strcspn(tokenString,divider);
@@ -562,13 +563,13 @@ static Unit *reduceUnit ( unitString )


   /*  process each subunit in turn, starting in the numerator
-
+
       Note that we're going to use a boolean flag to switch
       between numerator and denominator if we encounter a "/".
       This same style is used for processing recursively
       reduced subunits
   */
-  for (subunit=strtok(tokenString,separators); subunit!=NULL;
+  for (subunit=strtok(tokenString,separators); subunit!=NULL;
                         subunit=strtok(NULL,separators) ) {

     /* check for null subunit  */
@@ -624,9 +625,9 @@ static Unit *reduceUnit ( unitString )
     }


-    /*  Search the unit list in order, because we
-	wouldn't want to accidentally match the "m"
-	at the end of "gram" and conclude that we
+    /*  Search the unit list in order, because we
+	wouldn't want to accidentally match the "m"
+	at the end of "gram" and conclude that we
 	have "meter".   */
     len = strlen(subunit);
     p = NULL;
@@ -710,7 +711,7 @@ static Unit *reduceUnit ( unitString )
       } /* end if ends in "es" */
       free(subunitcopy);
     } /* end if ends in "s" */
-
+

     /*  If we fell through to here, without a match,
 	then we really have a bad unit name
@@ -738,7 +739,7 @@ static Unit *reduceUnit ( unitString )
     /*  Is this a primitive subunint?  */
     if ( up1->primitive ) {
       /*  just append the matching subunit to
-	  the result.
+	  the result.
 	  Actually, we can get away with inserting
 	  at the head of the numerator/denominator
 	  lists because we will sort them later.
@@ -767,9 +768,9 @@ static Unit *reduceUnit ( unitString )
 	  u->factor /= up1->factor;
 	}
       }
-
+
       /*  Add primitive subunits to numerator/denominator
-
+
 	  Note that we're use a nested boolean flag to switch
 	  between numerator and denominator.  Subunits in
 	  the numerator of the unitString are processed
@@ -809,7 +810,7 @@ static Unit *reduceUnit ( unitString )
 	  }
 	}
       }
-
+
     } /* end if non-primitive unit */

   } /* end for each subunit */
@@ -864,7 +865,7 @@ static Unit *sortUnitList( u )
     *(a+len)=u1;
     len++;
   }
-  /*
+  /*
    *  Sort the array of pointers using an insertion sort.
    *  This isn't really any more complicated than writing
    *  the comparison function and calling qsort().
@@ -899,14 +900,14 @@ static void cancelUnitList(numerator, denominator)
      Unit **denominator;  /*  denominator list of units  */
 {
   Unit *n1, *n2, *d1, *d2;
-  /*
+  /*
    *  March through the list with dual pointers so we
    *  can keep the forward-only links intact.
    */
   n1=NULL;
   n2=*numerator;
   while (n2!=NULL) {
-
+
     /* search denominator for matching unit */
     d1=NULL;
     d2=*denominator;
@@ -939,7 +940,7 @@ static void cancelUnitList(numerator, denominator)
       }
     } /* end while searching denominator */

-    /*
+    /*
      *  If we ran off end of denominator, move on to
      *  next numerator element.  If not, then we fell
      *  out of the loops after deleting a subunit, so
@@ -959,16 +960,16 @@ static void cancelUnitList(numerator, denominator)
  *
  *  UNIT table
  *
- *  Make sure that you change the unitcount variable if
+ *  Make sure that you change the unitcount variable if
  *  you change the unit initialization.
  *
- *  Users can add units to this table with the function
+ *  Users can add units to this table with the function
  *  int newUnitConversion( const char* unitName, const char* baseUnits)
  *
  *  Note that unit strings are parsed from the end using a first-
  *  match comparison.  The table should list the long unit names
  *  first, then abbreviations, such that a short match won't
- *  override a long match.  For example, the "s" abbreviation for
+ *  override a long match.  For example, the "s" abbreviation for
  *  "seconds" should come after the "siemens" unit.  It is OK
  *  to define units in terms of other units' abbreviations, even
  *  though they appear later in the table.
@@ -1114,18 +1115,18 @@ static char *nonSIabbreviations[] = {
  *
  *  PREFIX table
  *
- *  Make sure that you change the prefixcount variable if
+ *  Make sure that you change the prefixcount variable if
  *  you change the prefix initialization.
  *
  *  Note that prefix strings are parsed from the beginning using a
  *  first-match comparison.  The table should list the long prefixes
  *  first, then abbreviations, such that a short match won't
- *  override a long match.  For example, the "m" abbreviation for
+ *  override a long match.  For example, the "m" abbreviation for
  *  "milli" should come after both "milli" and "micro".
  *
  *  The SI prefixes included here are described in NIST Special
  *  Publication 330, 1991 Edition, "The Interational System of
- *  Units (SI)".  Note that we support the non-USA spelling of
+ *  Units (SI)".  Note that we support the non-USA spelling of
  *  deka- (deca-) and that we take the liberty of allowing
  *  the "micro-" prefix to be typed with a "u".
  *
@@ -1137,12 +1138,12 @@ static char *prefixList[] = {
   "exa",	"1e18",
   "peta",	"1e15",
   "tera",	"1e12",
-  "giga",	"1e9",
-  "mega",	"1e6",
-  "kilo",	"1e3",
+  "giga",	"1e9",
+  "mega",	"1e6",
+  "kilo",	"1e3",
   "hecto",	"1e2",
-  "deka",	"1e1",
-  "deca",	"1e1",
+  "deka",	"1e1",
+  "deca",	"1e1",
   "deci",	"1e-1",
   "centi",	"1e-2",
   "milli",	"1e-3",
@@ -1184,7 +1185,7 @@ static int unitInitialize() {
   for (name=prefixList,value=name+1; *name!=NULL; name+=2,value+=2) {
     p = createprefix(*name,atof(*value));
     if ( p == NULL ) {
-      throw_exception2("units failure initializing prefix '%s' (%s)",
+      throw_exception2("units failure initializing prefix '%s' (%s)",
 		       *name, *value);
       return FAILURE;
     }
@@ -1201,7 +1202,7 @@ static int unitInitialize() {
   for (name=baseUnits; *name!=NULL; name++) {
     u = createunit();
     if ( u == NULL ) {
-      throw_exception1("units failure initializing primitive unit '%s'",
+      throw_exception1("units failure initializing primitive unit '%s'",
 		       *name);
       return FAILURE;
     }
@@ -1220,7 +1221,7 @@ static int unitInitialize() {
   for (name=derivedUnits,value=name+1; *name!=NULL; name+=2,value+=2) {
     u = reduceUnit(*value);
     if ( u == NULL ) {
-      throw_exception2("units failure initializing derived unit '%s' (%s)",
+      throw_exception2("units failure initializing derived unit '%s' (%s)",
 		       *name, *value);
       return FAILURE;
     }
@@ -1228,12 +1229,12 @@ static int unitInitialize() {
     up->next = u;
     up = u;
   }
-
+
   /*  Load Units List with Non-SI Units  */
   for (name=nonSIUnits,value=name+1; *name!=NULL; name+=2,value+=2) {
     u = reduceUnit(*value);
     if ( u == NULL ) {
-      throw_exception2("units failure initializing non-SI unit '%s' (%s)",
+      throw_exception2("units failure initializing non-SI unit '%s' (%s)",
 		       *name, *value);
       return FAILURE;
     }
@@ -1241,12 +1242,12 @@ static int unitInitialize() {
     up->next = u;
     up = u;
   }
-
+
   /*  Load Units List with Abbreviations  */
   for (name=abbreviations,value=name+1; *name!=NULL; name+=2,value+=2) {
     u = reduceUnit(*value);
     if ( u == NULL ) {
-      throw_exception2("units failure initializing abbreviation '%s' (%s)",
+      throw_exception2("units failure initializing abbreviation '%s' (%s)",
 		       *name, *value);
       return FAILURE;
     }
@@ -1259,7 +1260,7 @@ static int unitInitialize() {
   for (name=nonSIabbreviations,value=name+1; *name!=NULL; name+=2,value+=2) {
     u = reduceUnit(*value);
     if ( u == NULL ) {
-      throw_exception2("units failure initializing non-SI abbreviation '%s' (%s)",
+      throw_exception2("units failure initializing non-SI abbreviation '%s' (%s)",
 		       *name, *value);
       return FAILURE;
     }
@@ -1270,7 +1271,3 @@ static int unitInitialize() {

   return SUCCESS;
 }
-
-
-
-
